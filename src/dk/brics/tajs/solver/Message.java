package dk.brics.tajs.solver;

import dk.brics.tajs.flowgraph.Node;

/**
 * Message generated by the analysis.
 */
public class Message implements Comparable<Message> {
	
	/**
	 * Message kind.
	 */
	public enum Status {

		/**
		 * The situation <i>definitely</i> occurs in all executions of the instruction.
		 */
		CERTAIN, 

		/**
		 * The situation <i>may</i> occur in some executions of the instruction.
		 */
		MAYBE, 

		/**
		 * Informational.
		 */
		INFO,

		/**
		 * The situation <i>does not</i> occur in any execution of the instruction.
		 */
		NONE
	}; 
	
	/**
	 * Severity level.
	 */
	public enum Severity { // order of declarations determines sorting order
		
		/**
		 * Important, an runtime error is generated if this situation occurs.
		 */
		HIGH,
		
		/**
		 * Likely an error if this situation occurs, but only report if certain.
		 */
		MEDIUM_IF_CERTAIN_NONE_OTHERWISE,
		
		/**
		 * Likely an error if this situation occurs.
		 */
		MEDIUM,
		
		/**
		 * Probably not an error if this situation occurs.
		 */
		LOW,
	}
	
	private Node node;
	
	private String msg;
	
	private String key;
	
	private Status status;
	
	private Severity severity;
	
	private boolean use_source_location; // use source location instead of node in equals/hashCode
	
	/**
	 * Constructs a new message.
	 * @param node flow graph node
	 * @param status message status
	 * @param key message key for comparisons
	 * @param msg the message
	 * @param severity severity level
	 */
	public Message(Node node, Status status, String key, String msg, Severity severity) {
		this(node, status, key, msg, severity, false);
	}
	
	/**
	 * Constructs a new message.
	 * @param node flow graph node
	 * @param status message status
	 * @param msg the message, also used as key
	 * @param severity severity level
	 * @param use_source_location if set, use node source location instead of node identity in equals/hashCode
	 */
	public Message(Node node, Status status,String msg, Severity severity, boolean use_source_location) {
		this(node, status, msg, msg, severity, use_source_location);
	}
	
	/**
	 * Constructs a new message.
	 * @param node flow graph node
	 * @param status message status
	 * @param key message key for comparisons
	 * @param msg the message
	 * @param severity severity level
	 * @param use_source_location if set, use node source location instead of node identity in equals/hashCode
	 */
	public Message(Node node, Status status, String key, String msg, Severity severity, boolean use_source_location) {
		this.node = node;
		this.key = key;
		this.msg = msg;
		this.status = status;
		this.severity = severity;
		this.use_source_location = use_source_location;
	}
	
	/**
	 * Returns a hash code for this message.
	 * Does not consider the status.
	 */
	@Override
	public int hashCode() {
		return (use_source_location ? node.getSourceLocation().hashCode() : node.getIndex()) * 7 + key.hashCode() * 5;
	}

	/**
	 * Checks whether this message is equal to the given.
	 * Does not consider the status.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Message other = (Message) obj;
		if (use_source_location ? (!node.getSourceLocation().equals(other.node.getSourceLocation())) : (node != other.node))
			return false;
		if (!key.equals(other.key))
			return false;
		if (severity != other.severity)
			return false;
		return true;
	}

	/**
	 * Returns the node associated with this message.
	 */
	public Node getNode() {
		return node;
	}
	
	/**
	 * Returns the message text.
	 */
	public String getMessage() {
		return msg;
	}
	
	/**
	 * Returns the message status.
	 */
	public Status getStatus() {
		return status;
	}
	
	/**
	 * Returns the message severity level.
	 */
	public Severity getSeverity() {
		return severity;
	}
	
	/**
	 * Returns a string description of this message.
	 */
	@Override
	public String toString() {
		StringBuilder b = new StringBuilder();
		b.append(node.getSourceLocation()).append(": [");
		switch(status) {
		case CERTAIN:
			b.append("definite");
			break;
		case MAYBE:
			b.append("maybe");
			break;
		case INFO:
			b.append("info");
			break;
		case NONE:
			b.append("none");
			break;
		}
		b.append("] ").append(msg);
		return b.toString();
	}
	
	/**
	 * Joins the given status into this message.
	 */
	public void join(Status status) {
		if (status.equals(Status.MAYBE)
				|| (status.equals(Status.CERTAIN) && this.status.equals(Status.NONE))
				|| (status.equals(Status.NONE) && this.status.equals(Status.CERTAIN)))
				this.status = Status.MAYBE;
		else if (this.status.equals(Status.INFO))
			this.status = status;
	}
	
	/**
	 * Compares this and the given message.
	 * The severity level is used as primary key (HIGH, MEDIUM, LOW)
	 * status is secondary (CERTAIN, MAYBE, INFO, NONE), 
	 * then source location, and finally the message text.
	 */
	@Override
	public int compareTo(Message e) { // TODO: reconsider message ordering?
		int c = status.ordinal() - e.status.ordinal();
		if (c != 0)
			return c;
		c = severity.ordinal() - e.severity.ordinal();
		if (c != 0)
			return c;
		c = node.getSourceLocation().compareTo(e.node.getSourceLocation());
		if (c != 0)
			return c;
		return key.compareTo(e.key);
	}
}
